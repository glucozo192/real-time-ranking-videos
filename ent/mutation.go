// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/glu/video-real-time-ranking/ent/comments"
	"github.com/glu/video-real-time-ranking/ent/objects"
	"github.com/glu/video-real-time-ranking/ent/predicate"
	"github.com/glu/video-real-time-ranking/ent/reactions"
	"github.com/glu/video-real-time-ranking/ent/videos"
	"github.com/glu/video-real-time-ranking/ent/viewers"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeComments  = "Comments"
	TypeObjects   = "Objects"
	TypeReactions = "Reactions"
	TypeVideos    = "Videos"
	TypeViewers   = "Viewers"
)

// CommentsMutation represents an operation that mutates the Comments nodes in the graph.
type CommentsMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	description       *string
	comment           *string
	user_name         *string
	avatar            *string
	time_point        *float64
	addtime_point     *float64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	tbl_videos        *uint
	clearedtbl_videos bool
	done              bool
	oldValue          func(context.Context) (*Comments, error)
	predicates        []predicate.Comments
}

var _ ent.Mutation = (*CommentsMutation)(nil)

// commentsOption allows management of the mutation configuration using functional options.
type commentsOption func(*CommentsMutation)

// newCommentsMutation creates new mutation for the Comments entity.
func newCommentsMutation(c config, op Op, opts ...commentsOption) *CommentsMutation {
	m := &CommentsMutation{
		config:        c,
		op:            op,
		typ:           TypeComments,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentsID sets the ID field of the mutation.
func withCommentsID(id uint) commentsOption {
	return func(m *CommentsMutation) {
		var (
			err   error
			once  sync.Once
			value *Comments
		)
		m.oldValue = func(ctx context.Context) (*Comments, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comments.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComments sets the old Comments of the mutation.
func withComments(node *Comments) commentsOption {
	return func(m *CommentsMutation) {
		m.oldValue = func(context.Context) (*Comments, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comments entities.
func (m *CommentsMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentsMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentsMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comments.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVideoID sets the "video_id" field.
func (m *CommentsMutation) SetVideoID(u uint) {
	m.tbl_videos = &u
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *CommentsMutation) VideoID() (r uint, exists bool) {
	v := m.tbl_videos
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldVideoID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *CommentsMutation) ResetVideoID() {
	m.tbl_videos = nil
}

// SetDescription sets the "description" field.
func (m *CommentsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommentsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CommentsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[comments.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CommentsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[comments.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CommentsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, comments.FieldDescription)
}

// SetComment sets the "comment" field.
func (m *CommentsMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *CommentsMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *CommentsMutation) ResetComment() {
	m.comment = nil
}

// SetUserName sets the "user_name" field.
func (m *CommentsMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *CommentsMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName resets all changes to the "user_name" field.
func (m *CommentsMutation) ResetUserName() {
	m.user_name = nil
}

// SetAvatar sets the "avatar" field.
func (m *CommentsMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *CommentsMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *CommentsMutation) ResetAvatar() {
	m.avatar = nil
}

// SetTimePoint sets the "time_point" field.
func (m *CommentsMutation) SetTimePoint(f float64) {
	m.time_point = &f
	m.addtime_point = nil
}

// TimePoint returns the value of the "time_point" field in the mutation.
func (m *CommentsMutation) TimePoint() (r float64, exists bool) {
	v := m.time_point
	if v == nil {
		return
	}
	return *v, true
}

// OldTimePoint returns the old "time_point" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldTimePoint(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimePoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimePoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimePoint: %w", err)
	}
	return oldValue.TimePoint, nil
}

// AddTimePoint adds f to the "time_point" field.
func (m *CommentsMutation) AddTimePoint(f float64) {
	if m.addtime_point != nil {
		*m.addtime_point += f
	} else {
		m.addtime_point = &f
	}
}

// AddedTimePoint returns the value that was added to the "time_point" field in this mutation.
func (m *CommentsMutation) AddedTimePoint() (r float64, exists bool) {
	v := m.addtime_point
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimePoint resets all changes to the "time_point" field.
func (m *CommentsMutation) ResetTimePoint() {
	m.time_point = nil
	m.addtime_point = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommentsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommentsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CommentsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[comments.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CommentsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[comments.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommentsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, comments.FieldDeletedAt)
}

// SetTblVideosID sets the "tbl_videos" edge to the Videos entity by id.
func (m *CommentsMutation) SetTblVideosID(id uint) {
	m.tbl_videos = &id
}

// ClearTblVideos clears the "tbl_videos" edge to the Videos entity.
func (m *CommentsMutation) ClearTblVideos() {
	m.clearedtbl_videos = true
	m.clearedFields[comments.FieldVideoID] = struct{}{}
}

// TblVideosCleared reports if the "tbl_videos" edge to the Videos entity was cleared.
func (m *CommentsMutation) TblVideosCleared() bool {
	return m.clearedtbl_videos
}

// TblVideosID returns the "tbl_videos" edge ID in the mutation.
func (m *CommentsMutation) TblVideosID() (id uint, exists bool) {
	if m.tbl_videos != nil {
		return *m.tbl_videos, true
	}
	return
}

// TblVideosIDs returns the "tbl_videos" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TblVideosID instead. It exists only for internal usage by the builders.
func (m *CommentsMutation) TblVideosIDs() (ids []uint) {
	if id := m.tbl_videos; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTblVideos resets all changes to the "tbl_videos" edge.
func (m *CommentsMutation) ResetTblVideos() {
	m.tbl_videos = nil
	m.clearedtbl_videos = false
}

// Where appends a list predicates to the CommentsMutation builder.
func (m *CommentsMutation) Where(ps ...predicate.Comments) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comments, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comments).
func (m *CommentsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.tbl_videos != nil {
		fields = append(fields, comments.FieldVideoID)
	}
	if m.description != nil {
		fields = append(fields, comments.FieldDescription)
	}
	if m.comment != nil {
		fields = append(fields, comments.FieldComment)
	}
	if m.user_name != nil {
		fields = append(fields, comments.FieldUserName)
	}
	if m.avatar != nil {
		fields = append(fields, comments.FieldAvatar)
	}
	if m.time_point != nil {
		fields = append(fields, comments.FieldTimePoint)
	}
	if m.created_at != nil {
		fields = append(fields, comments.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comments.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, comments.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comments.FieldVideoID:
		return m.VideoID()
	case comments.FieldDescription:
		return m.Description()
	case comments.FieldComment:
		return m.Comment()
	case comments.FieldUserName:
		return m.UserName()
	case comments.FieldAvatar:
		return m.Avatar()
	case comments.FieldTimePoint:
		return m.TimePoint()
	case comments.FieldCreatedAt:
		return m.CreatedAt()
	case comments.FieldUpdatedAt:
		return m.UpdatedAt()
	case comments.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comments.FieldVideoID:
		return m.OldVideoID(ctx)
	case comments.FieldDescription:
		return m.OldDescription(ctx)
	case comments.FieldComment:
		return m.OldComment(ctx)
	case comments.FieldUserName:
		return m.OldUserName(ctx)
	case comments.FieldAvatar:
		return m.OldAvatar(ctx)
	case comments.FieldTimePoint:
		return m.OldTimePoint(ctx)
	case comments.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comments.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comments.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comments field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comments.FieldVideoID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case comments.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case comments.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case comments.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case comments.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case comments.FieldTimePoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimePoint(v)
		return nil
	case comments.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comments.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comments.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comments field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentsMutation) AddedFields() []string {
	var fields []string
	if m.addtime_point != nil {
		fields = append(fields, comments.FieldTimePoint)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comments.FieldTimePoint:
		return m.AddedTimePoint()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comments.FieldTimePoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimePoint(v)
		return nil
	}
	return fmt.Errorf("unknown Comments numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comments.FieldDescription) {
		fields = append(fields, comments.FieldDescription)
	}
	if m.FieldCleared(comments.FieldDeletedAt) {
		fields = append(fields, comments.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentsMutation) ClearField(name string) error {
	switch name {
	case comments.FieldDescription:
		m.ClearDescription()
		return nil
	case comments.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Comments nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentsMutation) ResetField(name string) error {
	switch name {
	case comments.FieldVideoID:
		m.ResetVideoID()
		return nil
	case comments.FieldDescription:
		m.ResetDescription()
		return nil
	case comments.FieldComment:
		m.ResetComment()
		return nil
	case comments.FieldUserName:
		m.ResetUserName()
		return nil
	case comments.FieldAvatar:
		m.ResetAvatar()
		return nil
	case comments.FieldTimePoint:
		m.ResetTimePoint()
		return nil
	case comments.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comments.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comments.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Comments field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tbl_videos != nil {
		edges = append(edges, comments.EdgeTblVideos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comments.EdgeTblVideos:
		if id := m.tbl_videos; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtbl_videos {
		edges = append(edges, comments.EdgeTblVideos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentsMutation) EdgeCleared(name string) bool {
	switch name {
	case comments.EdgeTblVideos:
		return m.clearedtbl_videos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentsMutation) ClearEdge(name string) error {
	switch name {
	case comments.EdgeTblVideos:
		m.ClearTblVideos()
		return nil
	}
	return fmt.Errorf("unknown Comments unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentsMutation) ResetEdge(name string) error {
	switch name {
	case comments.EdgeTblVideos:
		m.ResetTblVideos()
		return nil
	}
	return fmt.Errorf("unknown Comments edge %s", name)
}

// ObjectsMutation represents an operation that mutates the Objects nodes in the graph.
type ObjectsMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	description       *string
	coordinate_x      *int
	addcoordinate_x   *int
	coordinate_y      *int
	addcoordinate_y   *int
	length            *int
	addlength         *int
	width             *int
	addwidth          *int
	_order            *int
	add_order         *int
	time_start        *float64
	addtime_start     *float64
	time_end          *float64
	addtime_end       *float64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	touch_vector      *string
	marker_name       *string
	time_point        *float64
	addtime_point     *float64
	clearedFields     map[string]struct{}
	tbl_videos        *uint
	clearedtbl_videos bool
	done              bool
	oldValue          func(context.Context) (*Objects, error)
	predicates        []predicate.Objects
}

var _ ent.Mutation = (*ObjectsMutation)(nil)

// objectsOption allows management of the mutation configuration using functional options.
type objectsOption func(*ObjectsMutation)

// newObjectsMutation creates new mutation for the Objects entity.
func newObjectsMutation(c config, op Op, opts ...objectsOption) *ObjectsMutation {
	m := &ObjectsMutation{
		config:        c,
		op:            op,
		typ:           TypeObjects,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withObjectsID sets the ID field of the mutation.
func withObjectsID(id uint) objectsOption {
	return func(m *ObjectsMutation) {
		var (
			err   error
			once  sync.Once
			value *Objects
		)
		m.oldValue = func(ctx context.Context) (*Objects, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Objects.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withObjects sets the old Objects of the mutation.
func withObjects(node *Objects) objectsOption {
	return func(m *ObjectsMutation) {
		m.oldValue = func(context.Context) (*Objects, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ObjectsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ObjectsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Objects entities.
func (m *ObjectsMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ObjectsMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ObjectsMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Objects.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVideoID sets the "video_id" field.
func (m *ObjectsMutation) SetVideoID(u uint) {
	m.tbl_videos = &u
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *ObjectsMutation) VideoID() (r uint, exists bool) {
	v := m.tbl_videos
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldVideoID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *ObjectsMutation) ResetVideoID() {
	m.tbl_videos = nil
}

// SetDescription sets the "description" field.
func (m *ObjectsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ObjectsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ObjectsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[objects.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ObjectsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[objects.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ObjectsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, objects.FieldDescription)
}

// SetCoordinateX sets the "coordinate_x" field.
func (m *ObjectsMutation) SetCoordinateX(i int) {
	m.coordinate_x = &i
	m.addcoordinate_x = nil
}

// CoordinateX returns the value of the "coordinate_x" field in the mutation.
func (m *ObjectsMutation) CoordinateX() (r int, exists bool) {
	v := m.coordinate_x
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinateX returns the old "coordinate_x" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldCoordinateX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinateX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinateX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinateX: %w", err)
	}
	return oldValue.CoordinateX, nil
}

// AddCoordinateX adds i to the "coordinate_x" field.
func (m *ObjectsMutation) AddCoordinateX(i int) {
	if m.addcoordinate_x != nil {
		*m.addcoordinate_x += i
	} else {
		m.addcoordinate_x = &i
	}
}

// AddedCoordinateX returns the value that was added to the "coordinate_x" field in this mutation.
func (m *ObjectsMutation) AddedCoordinateX() (r int, exists bool) {
	v := m.addcoordinate_x
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoordinateX resets all changes to the "coordinate_x" field.
func (m *ObjectsMutation) ResetCoordinateX() {
	m.coordinate_x = nil
	m.addcoordinate_x = nil
}

// SetCoordinateY sets the "coordinate_y" field.
func (m *ObjectsMutation) SetCoordinateY(i int) {
	m.coordinate_y = &i
	m.addcoordinate_y = nil
}

// CoordinateY returns the value of the "coordinate_y" field in the mutation.
func (m *ObjectsMutation) CoordinateY() (r int, exists bool) {
	v := m.coordinate_y
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinateY returns the old "coordinate_y" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldCoordinateY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinateY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinateY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinateY: %w", err)
	}
	return oldValue.CoordinateY, nil
}

// AddCoordinateY adds i to the "coordinate_y" field.
func (m *ObjectsMutation) AddCoordinateY(i int) {
	if m.addcoordinate_y != nil {
		*m.addcoordinate_y += i
	} else {
		m.addcoordinate_y = &i
	}
}

// AddedCoordinateY returns the value that was added to the "coordinate_y" field in this mutation.
func (m *ObjectsMutation) AddedCoordinateY() (r int, exists bool) {
	v := m.addcoordinate_y
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoordinateY resets all changes to the "coordinate_y" field.
func (m *ObjectsMutation) ResetCoordinateY() {
	m.coordinate_y = nil
	m.addcoordinate_y = nil
}

// SetLength sets the "length" field.
func (m *ObjectsMutation) SetLength(i int) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *ObjectsMutation) Length() (r int, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *ObjectsMutation) AddLength(i int) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *ObjectsMutation) AddedLength() (r int, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength resets all changes to the "length" field.
func (m *ObjectsMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// SetWidth sets the "width" field.
func (m *ObjectsMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *ObjectsMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *ObjectsMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *ObjectsMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *ObjectsMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetOrder sets the "order" field.
func (m *ObjectsMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *ObjectsMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *ObjectsMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *ObjectsMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *ObjectsMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetTimeStart sets the "time_start" field.
func (m *ObjectsMutation) SetTimeStart(f float64) {
	m.time_start = &f
	m.addtime_start = nil
}

// TimeStart returns the value of the "time_start" field in the mutation.
func (m *ObjectsMutation) TimeStart() (r float64, exists bool) {
	v := m.time_start
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeStart returns the old "time_start" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldTimeStart(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeStart: %w", err)
	}
	return oldValue.TimeStart, nil
}

// AddTimeStart adds f to the "time_start" field.
func (m *ObjectsMutation) AddTimeStart(f float64) {
	if m.addtime_start != nil {
		*m.addtime_start += f
	} else {
		m.addtime_start = &f
	}
}

// AddedTimeStart returns the value that was added to the "time_start" field in this mutation.
func (m *ObjectsMutation) AddedTimeStart() (r float64, exists bool) {
	v := m.addtime_start
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeStart resets all changes to the "time_start" field.
func (m *ObjectsMutation) ResetTimeStart() {
	m.time_start = nil
	m.addtime_start = nil
}

// SetTimeEnd sets the "time_end" field.
func (m *ObjectsMutation) SetTimeEnd(f float64) {
	m.time_end = &f
	m.addtime_end = nil
}

// TimeEnd returns the value of the "time_end" field in the mutation.
func (m *ObjectsMutation) TimeEnd() (r float64, exists bool) {
	v := m.time_end
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeEnd returns the old "time_end" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldTimeEnd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeEnd: %w", err)
	}
	return oldValue.TimeEnd, nil
}

// AddTimeEnd adds f to the "time_end" field.
func (m *ObjectsMutation) AddTimeEnd(f float64) {
	if m.addtime_end != nil {
		*m.addtime_end += f
	} else {
		m.addtime_end = &f
	}
}

// AddedTimeEnd returns the value that was added to the "time_end" field in this mutation.
func (m *ObjectsMutation) AddedTimeEnd() (r float64, exists bool) {
	v := m.addtime_end
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeEnd resets all changes to the "time_end" field.
func (m *ObjectsMutation) ResetTimeEnd() {
	m.time_end = nil
	m.addtime_end = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ObjectsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ObjectsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ObjectsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ObjectsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ObjectsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ObjectsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ObjectsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ObjectsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ObjectsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[objects.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ObjectsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[objects.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ObjectsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, objects.FieldDeletedAt)
}

// SetTouchVector sets the "touch_vector" field.
func (m *ObjectsMutation) SetTouchVector(s string) {
	m.touch_vector = &s
}

// TouchVector returns the value of the "touch_vector" field in the mutation.
func (m *ObjectsMutation) TouchVector() (r string, exists bool) {
	v := m.touch_vector
	if v == nil {
		return
	}
	return *v, true
}

// OldTouchVector returns the old "touch_vector" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldTouchVector(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTouchVector is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTouchVector requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTouchVector: %w", err)
	}
	return oldValue.TouchVector, nil
}

// ResetTouchVector resets all changes to the "touch_vector" field.
func (m *ObjectsMutation) ResetTouchVector() {
	m.touch_vector = nil
}

// SetMarkerName sets the "marker_name" field.
func (m *ObjectsMutation) SetMarkerName(s string) {
	m.marker_name = &s
}

// MarkerName returns the value of the "marker_name" field in the mutation.
func (m *ObjectsMutation) MarkerName() (r string, exists bool) {
	v := m.marker_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMarkerName returns the old "marker_name" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldMarkerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarkerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarkerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarkerName: %w", err)
	}
	return oldValue.MarkerName, nil
}

// ResetMarkerName resets all changes to the "marker_name" field.
func (m *ObjectsMutation) ResetMarkerName() {
	m.marker_name = nil
}

// SetTimePoint sets the "time_point" field.
func (m *ObjectsMutation) SetTimePoint(f float64) {
	m.time_point = &f
	m.addtime_point = nil
}

// TimePoint returns the value of the "time_point" field in the mutation.
func (m *ObjectsMutation) TimePoint() (r float64, exists bool) {
	v := m.time_point
	if v == nil {
		return
	}
	return *v, true
}

// OldTimePoint returns the old "time_point" field's value of the Objects entity.
// If the Objects object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectsMutation) OldTimePoint(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimePoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimePoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimePoint: %w", err)
	}
	return oldValue.TimePoint, nil
}

// AddTimePoint adds f to the "time_point" field.
func (m *ObjectsMutation) AddTimePoint(f float64) {
	if m.addtime_point != nil {
		*m.addtime_point += f
	} else {
		m.addtime_point = &f
	}
}

// AddedTimePoint returns the value that was added to the "time_point" field in this mutation.
func (m *ObjectsMutation) AddedTimePoint() (r float64, exists bool) {
	v := m.addtime_point
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimePoint resets all changes to the "time_point" field.
func (m *ObjectsMutation) ResetTimePoint() {
	m.time_point = nil
	m.addtime_point = nil
}

// SetTblVideosID sets the "tbl_videos" edge to the Videos entity by id.
func (m *ObjectsMutation) SetTblVideosID(id uint) {
	m.tbl_videos = &id
}

// ClearTblVideos clears the "tbl_videos" edge to the Videos entity.
func (m *ObjectsMutation) ClearTblVideos() {
	m.clearedtbl_videos = true
	m.clearedFields[objects.FieldVideoID] = struct{}{}
}

// TblVideosCleared reports if the "tbl_videos" edge to the Videos entity was cleared.
func (m *ObjectsMutation) TblVideosCleared() bool {
	return m.clearedtbl_videos
}

// TblVideosID returns the "tbl_videos" edge ID in the mutation.
func (m *ObjectsMutation) TblVideosID() (id uint, exists bool) {
	if m.tbl_videos != nil {
		return *m.tbl_videos, true
	}
	return
}

// TblVideosIDs returns the "tbl_videos" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TblVideosID instead. It exists only for internal usage by the builders.
func (m *ObjectsMutation) TblVideosIDs() (ids []uint) {
	if id := m.tbl_videos; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTblVideos resets all changes to the "tbl_videos" edge.
func (m *ObjectsMutation) ResetTblVideos() {
	m.tbl_videos = nil
	m.clearedtbl_videos = false
}

// Where appends a list predicates to the ObjectsMutation builder.
func (m *ObjectsMutation) Where(ps ...predicate.Objects) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ObjectsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ObjectsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Objects, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ObjectsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ObjectsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Objects).
func (m *ObjectsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ObjectsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.tbl_videos != nil {
		fields = append(fields, objects.FieldVideoID)
	}
	if m.description != nil {
		fields = append(fields, objects.FieldDescription)
	}
	if m.coordinate_x != nil {
		fields = append(fields, objects.FieldCoordinateX)
	}
	if m.coordinate_y != nil {
		fields = append(fields, objects.FieldCoordinateY)
	}
	if m.length != nil {
		fields = append(fields, objects.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, objects.FieldWidth)
	}
	if m._order != nil {
		fields = append(fields, objects.FieldOrder)
	}
	if m.time_start != nil {
		fields = append(fields, objects.FieldTimeStart)
	}
	if m.time_end != nil {
		fields = append(fields, objects.FieldTimeEnd)
	}
	if m.created_at != nil {
		fields = append(fields, objects.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, objects.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, objects.FieldDeletedAt)
	}
	if m.touch_vector != nil {
		fields = append(fields, objects.FieldTouchVector)
	}
	if m.marker_name != nil {
		fields = append(fields, objects.FieldMarkerName)
	}
	if m.time_point != nil {
		fields = append(fields, objects.FieldTimePoint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ObjectsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case objects.FieldVideoID:
		return m.VideoID()
	case objects.FieldDescription:
		return m.Description()
	case objects.FieldCoordinateX:
		return m.CoordinateX()
	case objects.FieldCoordinateY:
		return m.CoordinateY()
	case objects.FieldLength:
		return m.Length()
	case objects.FieldWidth:
		return m.Width()
	case objects.FieldOrder:
		return m.Order()
	case objects.FieldTimeStart:
		return m.TimeStart()
	case objects.FieldTimeEnd:
		return m.TimeEnd()
	case objects.FieldCreatedAt:
		return m.CreatedAt()
	case objects.FieldUpdatedAt:
		return m.UpdatedAt()
	case objects.FieldDeletedAt:
		return m.DeletedAt()
	case objects.FieldTouchVector:
		return m.TouchVector()
	case objects.FieldMarkerName:
		return m.MarkerName()
	case objects.FieldTimePoint:
		return m.TimePoint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ObjectsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case objects.FieldVideoID:
		return m.OldVideoID(ctx)
	case objects.FieldDescription:
		return m.OldDescription(ctx)
	case objects.FieldCoordinateX:
		return m.OldCoordinateX(ctx)
	case objects.FieldCoordinateY:
		return m.OldCoordinateY(ctx)
	case objects.FieldLength:
		return m.OldLength(ctx)
	case objects.FieldWidth:
		return m.OldWidth(ctx)
	case objects.FieldOrder:
		return m.OldOrder(ctx)
	case objects.FieldTimeStart:
		return m.OldTimeStart(ctx)
	case objects.FieldTimeEnd:
		return m.OldTimeEnd(ctx)
	case objects.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case objects.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case objects.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case objects.FieldTouchVector:
		return m.OldTouchVector(ctx)
	case objects.FieldMarkerName:
		return m.OldMarkerName(ctx)
	case objects.FieldTimePoint:
		return m.OldTimePoint(ctx)
	}
	return nil, fmt.Errorf("unknown Objects field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case objects.FieldVideoID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case objects.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case objects.FieldCoordinateX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinateX(v)
		return nil
	case objects.FieldCoordinateY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinateY(v)
		return nil
	case objects.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case objects.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case objects.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case objects.FieldTimeStart:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeStart(v)
		return nil
	case objects.FieldTimeEnd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeEnd(v)
		return nil
	case objects.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case objects.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case objects.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case objects.FieldTouchVector:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTouchVector(v)
		return nil
	case objects.FieldMarkerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarkerName(v)
		return nil
	case objects.FieldTimePoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimePoint(v)
		return nil
	}
	return fmt.Errorf("unknown Objects field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ObjectsMutation) AddedFields() []string {
	var fields []string
	if m.addcoordinate_x != nil {
		fields = append(fields, objects.FieldCoordinateX)
	}
	if m.addcoordinate_y != nil {
		fields = append(fields, objects.FieldCoordinateY)
	}
	if m.addlength != nil {
		fields = append(fields, objects.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, objects.FieldWidth)
	}
	if m.add_order != nil {
		fields = append(fields, objects.FieldOrder)
	}
	if m.addtime_start != nil {
		fields = append(fields, objects.FieldTimeStart)
	}
	if m.addtime_end != nil {
		fields = append(fields, objects.FieldTimeEnd)
	}
	if m.addtime_point != nil {
		fields = append(fields, objects.FieldTimePoint)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ObjectsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case objects.FieldCoordinateX:
		return m.AddedCoordinateX()
	case objects.FieldCoordinateY:
		return m.AddedCoordinateY()
	case objects.FieldLength:
		return m.AddedLength()
	case objects.FieldWidth:
		return m.AddedWidth()
	case objects.FieldOrder:
		return m.AddedOrder()
	case objects.FieldTimeStart:
		return m.AddedTimeStart()
	case objects.FieldTimeEnd:
		return m.AddedTimeEnd()
	case objects.FieldTimePoint:
		return m.AddedTimePoint()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case objects.FieldCoordinateX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoordinateX(v)
		return nil
	case objects.FieldCoordinateY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoordinateY(v)
		return nil
	case objects.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case objects.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case objects.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case objects.FieldTimeStart:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeStart(v)
		return nil
	case objects.FieldTimeEnd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeEnd(v)
		return nil
	case objects.FieldTimePoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimePoint(v)
		return nil
	}
	return fmt.Errorf("unknown Objects numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ObjectsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(objects.FieldDescription) {
		fields = append(fields, objects.FieldDescription)
	}
	if m.FieldCleared(objects.FieldDeletedAt) {
		fields = append(fields, objects.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ObjectsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ObjectsMutation) ClearField(name string) error {
	switch name {
	case objects.FieldDescription:
		m.ClearDescription()
		return nil
	case objects.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Objects nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ObjectsMutation) ResetField(name string) error {
	switch name {
	case objects.FieldVideoID:
		m.ResetVideoID()
		return nil
	case objects.FieldDescription:
		m.ResetDescription()
		return nil
	case objects.FieldCoordinateX:
		m.ResetCoordinateX()
		return nil
	case objects.FieldCoordinateY:
		m.ResetCoordinateY()
		return nil
	case objects.FieldLength:
		m.ResetLength()
		return nil
	case objects.FieldWidth:
		m.ResetWidth()
		return nil
	case objects.FieldOrder:
		m.ResetOrder()
		return nil
	case objects.FieldTimeStart:
		m.ResetTimeStart()
		return nil
	case objects.FieldTimeEnd:
		m.ResetTimeEnd()
		return nil
	case objects.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case objects.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case objects.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case objects.FieldTouchVector:
		m.ResetTouchVector()
		return nil
	case objects.FieldMarkerName:
		m.ResetMarkerName()
		return nil
	case objects.FieldTimePoint:
		m.ResetTimePoint()
		return nil
	}
	return fmt.Errorf("unknown Objects field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ObjectsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tbl_videos != nil {
		edges = append(edges, objects.EdgeTblVideos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ObjectsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case objects.EdgeTblVideos:
		if id := m.tbl_videos; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ObjectsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ObjectsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ObjectsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtbl_videos {
		edges = append(edges, objects.EdgeTblVideos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ObjectsMutation) EdgeCleared(name string) bool {
	switch name {
	case objects.EdgeTblVideos:
		return m.clearedtbl_videos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ObjectsMutation) ClearEdge(name string) error {
	switch name {
	case objects.EdgeTblVideos:
		m.ClearTblVideos()
		return nil
	}
	return fmt.Errorf("unknown Objects unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ObjectsMutation) ResetEdge(name string) error {
	switch name {
	case objects.EdgeTblVideos:
		m.ResetTblVideos()
		return nil
	}
	return fmt.Errorf("unknown Objects edge %s", name)
}

// ReactionsMutation represents an operation that mutates the Reactions nodes in the graph.
type ReactionsMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	description       *string
	name              *string
	number            *int
	addnumber         *int
	time_point        *float64
	addtime_point     *float64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	tbl_videos        *uint
	clearedtbl_videos bool
	done              bool
	oldValue          func(context.Context) (*Reactions, error)
	predicates        []predicate.Reactions
}

var _ ent.Mutation = (*ReactionsMutation)(nil)

// reactionsOption allows management of the mutation configuration using functional options.
type reactionsOption func(*ReactionsMutation)

// newReactionsMutation creates new mutation for the Reactions entity.
func newReactionsMutation(c config, op Op, opts ...reactionsOption) *ReactionsMutation {
	m := &ReactionsMutation{
		config:        c,
		op:            op,
		typ:           TypeReactions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReactionsID sets the ID field of the mutation.
func withReactionsID(id uint) reactionsOption {
	return func(m *ReactionsMutation) {
		var (
			err   error
			once  sync.Once
			value *Reactions
		)
		m.oldValue = func(ctx context.Context) (*Reactions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reactions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReactions sets the old Reactions of the mutation.
func withReactions(node *Reactions) reactionsOption {
	return func(m *ReactionsMutation) {
		m.oldValue = func(context.Context) (*Reactions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReactionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReactionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reactions entities.
func (m *ReactionsMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReactionsMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReactionsMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reactions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVideoID sets the "video_id" field.
func (m *ReactionsMutation) SetVideoID(u uint) {
	m.tbl_videos = &u
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *ReactionsMutation) VideoID() (r uint, exists bool) {
	v := m.tbl_videos
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the Reactions entity.
// If the Reactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionsMutation) OldVideoID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *ReactionsMutation) ResetVideoID() {
	m.tbl_videos = nil
}

// SetDescription sets the "description" field.
func (m *ReactionsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ReactionsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Reactions entity.
// If the Reactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ReactionsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[reactions.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ReactionsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[reactions.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ReactionsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, reactions.FieldDescription)
}

// SetName sets the "name" field.
func (m *ReactionsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReactionsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Reactions entity.
// If the Reactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReactionsMutation) ResetName() {
	m.name = nil
}

// SetNumber sets the "number" field.
func (m *ReactionsMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *ReactionsMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Reactions entity.
// If the Reactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionsMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *ReactionsMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *ReactionsMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *ReactionsMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetTimePoint sets the "time_point" field.
func (m *ReactionsMutation) SetTimePoint(f float64) {
	m.time_point = &f
	m.addtime_point = nil
}

// TimePoint returns the value of the "time_point" field in the mutation.
func (m *ReactionsMutation) TimePoint() (r float64, exists bool) {
	v := m.time_point
	if v == nil {
		return
	}
	return *v, true
}

// OldTimePoint returns the old "time_point" field's value of the Reactions entity.
// If the Reactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionsMutation) OldTimePoint(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimePoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimePoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimePoint: %w", err)
	}
	return oldValue.TimePoint, nil
}

// AddTimePoint adds f to the "time_point" field.
func (m *ReactionsMutation) AddTimePoint(f float64) {
	if m.addtime_point != nil {
		*m.addtime_point += f
	} else {
		m.addtime_point = &f
	}
}

// AddedTimePoint returns the value that was added to the "time_point" field in this mutation.
func (m *ReactionsMutation) AddedTimePoint() (r float64, exists bool) {
	v := m.addtime_point
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimePoint resets all changes to the "time_point" field.
func (m *ReactionsMutation) ResetTimePoint() {
	m.time_point = nil
	m.addtime_point = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReactionsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReactionsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Reactions entity.
// If the Reactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReactionsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReactionsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReactionsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Reactions entity.
// If the Reactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReactionsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ReactionsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ReactionsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Reactions entity.
// If the Reactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ReactionsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[reactions.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ReactionsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[reactions.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ReactionsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, reactions.FieldDeletedAt)
}

// SetTblVideosID sets the "tbl_videos" edge to the Videos entity by id.
func (m *ReactionsMutation) SetTblVideosID(id uint) {
	m.tbl_videos = &id
}

// ClearTblVideos clears the "tbl_videos" edge to the Videos entity.
func (m *ReactionsMutation) ClearTblVideos() {
	m.clearedtbl_videos = true
	m.clearedFields[reactions.FieldVideoID] = struct{}{}
}

// TblVideosCleared reports if the "tbl_videos" edge to the Videos entity was cleared.
func (m *ReactionsMutation) TblVideosCleared() bool {
	return m.clearedtbl_videos
}

// TblVideosID returns the "tbl_videos" edge ID in the mutation.
func (m *ReactionsMutation) TblVideosID() (id uint, exists bool) {
	if m.tbl_videos != nil {
		return *m.tbl_videos, true
	}
	return
}

// TblVideosIDs returns the "tbl_videos" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TblVideosID instead. It exists only for internal usage by the builders.
func (m *ReactionsMutation) TblVideosIDs() (ids []uint) {
	if id := m.tbl_videos; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTblVideos resets all changes to the "tbl_videos" edge.
func (m *ReactionsMutation) ResetTblVideos() {
	m.tbl_videos = nil
	m.clearedtbl_videos = false
}

// Where appends a list predicates to the ReactionsMutation builder.
func (m *ReactionsMutation) Where(ps ...predicate.Reactions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReactionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReactionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reactions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReactionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReactionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reactions).
func (m *ReactionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReactionsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tbl_videos != nil {
		fields = append(fields, reactions.FieldVideoID)
	}
	if m.description != nil {
		fields = append(fields, reactions.FieldDescription)
	}
	if m.name != nil {
		fields = append(fields, reactions.FieldName)
	}
	if m.number != nil {
		fields = append(fields, reactions.FieldNumber)
	}
	if m.time_point != nil {
		fields = append(fields, reactions.FieldTimePoint)
	}
	if m.created_at != nil {
		fields = append(fields, reactions.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reactions.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, reactions.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReactionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reactions.FieldVideoID:
		return m.VideoID()
	case reactions.FieldDescription:
		return m.Description()
	case reactions.FieldName:
		return m.Name()
	case reactions.FieldNumber:
		return m.Number()
	case reactions.FieldTimePoint:
		return m.TimePoint()
	case reactions.FieldCreatedAt:
		return m.CreatedAt()
	case reactions.FieldUpdatedAt:
		return m.UpdatedAt()
	case reactions.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReactionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reactions.FieldVideoID:
		return m.OldVideoID(ctx)
	case reactions.FieldDescription:
		return m.OldDescription(ctx)
	case reactions.FieldName:
		return m.OldName(ctx)
	case reactions.FieldNumber:
		return m.OldNumber(ctx)
	case reactions.FieldTimePoint:
		return m.OldTimePoint(ctx)
	case reactions.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reactions.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reactions.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Reactions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reactions.FieldVideoID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case reactions.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case reactions.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case reactions.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case reactions.FieldTimePoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimePoint(v)
		return nil
	case reactions.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reactions.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reactions.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Reactions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReactionsMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, reactions.FieldNumber)
	}
	if m.addtime_point != nil {
		fields = append(fields, reactions.FieldTimePoint)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReactionsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reactions.FieldNumber:
		return m.AddedNumber()
	case reactions.FieldTimePoint:
		return m.AddedTimePoint()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reactions.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case reactions.FieldTimePoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimePoint(v)
		return nil
	}
	return fmt.Errorf("unknown Reactions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReactionsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reactions.FieldDescription) {
		fields = append(fields, reactions.FieldDescription)
	}
	if m.FieldCleared(reactions.FieldDeletedAt) {
		fields = append(fields, reactions.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReactionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReactionsMutation) ClearField(name string) error {
	switch name {
	case reactions.FieldDescription:
		m.ClearDescription()
		return nil
	case reactions.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Reactions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReactionsMutation) ResetField(name string) error {
	switch name {
	case reactions.FieldVideoID:
		m.ResetVideoID()
		return nil
	case reactions.FieldDescription:
		m.ResetDescription()
		return nil
	case reactions.FieldName:
		m.ResetName()
		return nil
	case reactions.FieldNumber:
		m.ResetNumber()
		return nil
	case reactions.FieldTimePoint:
		m.ResetTimePoint()
		return nil
	case reactions.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reactions.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reactions.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Reactions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReactionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tbl_videos != nil {
		edges = append(edges, reactions.EdgeTblVideos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReactionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reactions.EdgeTblVideos:
		if id := m.tbl_videos; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReactionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReactionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReactionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtbl_videos {
		edges = append(edges, reactions.EdgeTblVideos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReactionsMutation) EdgeCleared(name string) bool {
	switch name {
	case reactions.EdgeTblVideos:
		return m.clearedtbl_videos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReactionsMutation) ClearEdge(name string) error {
	switch name {
	case reactions.EdgeTblVideos:
		m.ClearTblVideos()
		return nil
	}
	return fmt.Errorf("unknown Reactions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReactionsMutation) ResetEdge(name string) error {
	switch name {
	case reactions.EdgeTblVideos:
		m.ResetTblVideos()
		return nil
	}
	return fmt.Errorf("unknown Reactions edge %s", name)
}

// VideosMutation represents an operation that mutates the Videos nodes in the graph.
type VideosMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint
	name                 *string
	description          *string
	video_url            *string
	_config              *string
	path_resource        *string
	level_system         *string
	status               *string
	note                 *string
	assign               *string
	version              *uint
	addversion           *int
	_Author              *string
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	clearedFields        map[string]struct{}
	tbl_comments         map[uint]struct{}
	removedtbl_comments  map[uint]struct{}
	clearedtbl_comments  bool
	tbl_reactions        map[uint]struct{}
	removedtbl_reactions map[uint]struct{}
	clearedtbl_reactions bool
	tbl_viewers          map[uint]struct{}
	removedtbl_viewers   map[uint]struct{}
	clearedtbl_viewers   bool
	tbl_objects          map[uint]struct{}
	removedtbl_objects   map[uint]struct{}
	clearedtbl_objects   bool
	done                 bool
	oldValue             func(context.Context) (*Videos, error)
	predicates           []predicate.Videos
}

var _ ent.Mutation = (*VideosMutation)(nil)

// videosOption allows management of the mutation configuration using functional options.
type videosOption func(*VideosMutation)

// newVideosMutation creates new mutation for the Videos entity.
func newVideosMutation(c config, op Op, opts ...videosOption) *VideosMutation {
	m := &VideosMutation{
		config:        c,
		op:            op,
		typ:           TypeVideos,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideosID sets the ID field of the mutation.
func withVideosID(id uint) videosOption {
	return func(m *VideosMutation) {
		var (
			err   error
			once  sync.Once
			value *Videos
		)
		m.oldValue = func(ctx context.Context) (*Videos, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Videos.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideos sets the old Videos of the mutation.
func withVideos(node *Videos) videosOption {
	return func(m *VideosMutation) {
		m.oldValue = func(context.Context) (*Videos, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideosMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideosMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Videos entities.
func (m *VideosMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideosMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideosMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Videos.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *VideosMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VideosMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VideosMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *VideosMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VideosMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VideosMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[videos.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VideosMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[videos.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VideosMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, videos.FieldDescription)
}

// SetVideoURL sets the "video_url" field.
func (m *VideosMutation) SetVideoURL(s string) {
	m.video_url = &s
}

// VideoURL returns the value of the "video_url" field in the mutation.
func (m *VideosMutation) VideoURL() (r string, exists bool) {
	v := m.video_url
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoURL returns the old "video_url" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldVideoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoURL: %w", err)
	}
	return oldValue.VideoURL, nil
}

// ResetVideoURL resets all changes to the "video_url" field.
func (m *VideosMutation) ResetVideoURL() {
	m.video_url = nil
}

// SetConfig sets the "config" field.
func (m *VideosMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *VideosMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *VideosMutation) ResetConfig() {
	m._config = nil
}

// SetPathResource sets the "path_resource" field.
func (m *VideosMutation) SetPathResource(s string) {
	m.path_resource = &s
}

// PathResource returns the value of the "path_resource" field in the mutation.
func (m *VideosMutation) PathResource() (r string, exists bool) {
	v := m.path_resource
	if v == nil {
		return
	}
	return *v, true
}

// OldPathResource returns the old "path_resource" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldPathResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPathResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPathResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPathResource: %w", err)
	}
	return oldValue.PathResource, nil
}

// ResetPathResource resets all changes to the "path_resource" field.
func (m *VideosMutation) ResetPathResource() {
	m.path_resource = nil
}

// SetLevelSystem sets the "level_system" field.
func (m *VideosMutation) SetLevelSystem(s string) {
	m.level_system = &s
}

// LevelSystem returns the value of the "level_system" field in the mutation.
func (m *VideosMutation) LevelSystem() (r string, exists bool) {
	v := m.level_system
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelSystem returns the old "level_system" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldLevelSystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelSystem: %w", err)
	}
	return oldValue.LevelSystem, nil
}

// ResetLevelSystem resets all changes to the "level_system" field.
func (m *VideosMutation) ResetLevelSystem() {
	m.level_system = nil
}

// SetStatus sets the "status" field.
func (m *VideosMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *VideosMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VideosMutation) ResetStatus() {
	m.status = nil
}

// SetNote sets the "note" field.
func (m *VideosMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *VideosMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *VideosMutation) ResetNote() {
	m.note = nil
}

// SetAssign sets the "assign" field.
func (m *VideosMutation) SetAssign(s string) {
	m.assign = &s
}

// Assign returns the value of the "assign" field in the mutation.
func (m *VideosMutation) Assign() (r string, exists bool) {
	v := m.assign
	if v == nil {
		return
	}
	return *v, true
}

// OldAssign returns the old "assign" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldAssign(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssign: %w", err)
	}
	return oldValue.Assign, nil
}

// ResetAssign resets all changes to the "assign" field.
func (m *VideosMutation) ResetAssign() {
	m.assign = nil
}

// SetVersion sets the "version" field.
func (m *VideosMutation) SetVersion(u uint) {
	m.version = &u
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *VideosMutation) Version() (r uint, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldVersion(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds u to the "version" field.
func (m *VideosMutation) AddVersion(u int) {
	if m.addversion != nil {
		*m.addversion += u
	} else {
		m.addversion = &u
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *VideosMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *VideosMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetAuthor sets the "Author" field.
func (m *VideosMutation) SetAuthor(s string) {
	m._Author = &s
}

// Author returns the value of the "Author" field in the mutation.
func (m *VideosMutation) Author() (r string, exists bool) {
	v := m._Author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "Author" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "Author" field.
func (m *VideosMutation) ResetAuthor() {
	m._Author = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VideosMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VideosMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VideosMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VideosMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VideosMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VideosMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VideosMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VideosMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Videos entity.
// If the Videos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideosMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VideosMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[videos.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VideosMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[videos.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VideosMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, videos.FieldDeletedAt)
}

// AddTblCommentIDs adds the "tbl_comments" edge to the Comments entity by ids.
func (m *VideosMutation) AddTblCommentIDs(ids ...uint) {
	if m.tbl_comments == nil {
		m.tbl_comments = make(map[uint]struct{})
	}
	for i := range ids {
		m.tbl_comments[ids[i]] = struct{}{}
	}
}

// ClearTblComments clears the "tbl_comments" edge to the Comments entity.
func (m *VideosMutation) ClearTblComments() {
	m.clearedtbl_comments = true
}

// TblCommentsCleared reports if the "tbl_comments" edge to the Comments entity was cleared.
func (m *VideosMutation) TblCommentsCleared() bool {
	return m.clearedtbl_comments
}

// RemoveTblCommentIDs removes the "tbl_comments" edge to the Comments entity by IDs.
func (m *VideosMutation) RemoveTblCommentIDs(ids ...uint) {
	if m.removedtbl_comments == nil {
		m.removedtbl_comments = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.tbl_comments, ids[i])
		m.removedtbl_comments[ids[i]] = struct{}{}
	}
}

// RemovedTblComments returns the removed IDs of the "tbl_comments" edge to the Comments entity.
func (m *VideosMutation) RemovedTblCommentsIDs() (ids []uint) {
	for id := range m.removedtbl_comments {
		ids = append(ids, id)
	}
	return
}

// TblCommentsIDs returns the "tbl_comments" edge IDs in the mutation.
func (m *VideosMutation) TblCommentsIDs() (ids []uint) {
	for id := range m.tbl_comments {
		ids = append(ids, id)
	}
	return
}

// ResetTblComments resets all changes to the "tbl_comments" edge.
func (m *VideosMutation) ResetTblComments() {
	m.tbl_comments = nil
	m.clearedtbl_comments = false
	m.removedtbl_comments = nil
}

// AddTblReactionIDs adds the "tbl_reactions" edge to the Reactions entity by ids.
func (m *VideosMutation) AddTblReactionIDs(ids ...uint) {
	if m.tbl_reactions == nil {
		m.tbl_reactions = make(map[uint]struct{})
	}
	for i := range ids {
		m.tbl_reactions[ids[i]] = struct{}{}
	}
}

// ClearTblReactions clears the "tbl_reactions" edge to the Reactions entity.
func (m *VideosMutation) ClearTblReactions() {
	m.clearedtbl_reactions = true
}

// TblReactionsCleared reports if the "tbl_reactions" edge to the Reactions entity was cleared.
func (m *VideosMutation) TblReactionsCleared() bool {
	return m.clearedtbl_reactions
}

// RemoveTblReactionIDs removes the "tbl_reactions" edge to the Reactions entity by IDs.
func (m *VideosMutation) RemoveTblReactionIDs(ids ...uint) {
	if m.removedtbl_reactions == nil {
		m.removedtbl_reactions = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.tbl_reactions, ids[i])
		m.removedtbl_reactions[ids[i]] = struct{}{}
	}
}

// RemovedTblReactions returns the removed IDs of the "tbl_reactions" edge to the Reactions entity.
func (m *VideosMutation) RemovedTblReactionsIDs() (ids []uint) {
	for id := range m.removedtbl_reactions {
		ids = append(ids, id)
	}
	return
}

// TblReactionsIDs returns the "tbl_reactions" edge IDs in the mutation.
func (m *VideosMutation) TblReactionsIDs() (ids []uint) {
	for id := range m.tbl_reactions {
		ids = append(ids, id)
	}
	return
}

// ResetTblReactions resets all changes to the "tbl_reactions" edge.
func (m *VideosMutation) ResetTblReactions() {
	m.tbl_reactions = nil
	m.clearedtbl_reactions = false
	m.removedtbl_reactions = nil
}

// AddTblViewerIDs adds the "tbl_viewers" edge to the Viewers entity by ids.
func (m *VideosMutation) AddTblViewerIDs(ids ...uint) {
	if m.tbl_viewers == nil {
		m.tbl_viewers = make(map[uint]struct{})
	}
	for i := range ids {
		m.tbl_viewers[ids[i]] = struct{}{}
	}
}

// ClearTblViewers clears the "tbl_viewers" edge to the Viewers entity.
func (m *VideosMutation) ClearTblViewers() {
	m.clearedtbl_viewers = true
}

// TblViewersCleared reports if the "tbl_viewers" edge to the Viewers entity was cleared.
func (m *VideosMutation) TblViewersCleared() bool {
	return m.clearedtbl_viewers
}

// RemoveTblViewerIDs removes the "tbl_viewers" edge to the Viewers entity by IDs.
func (m *VideosMutation) RemoveTblViewerIDs(ids ...uint) {
	if m.removedtbl_viewers == nil {
		m.removedtbl_viewers = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.tbl_viewers, ids[i])
		m.removedtbl_viewers[ids[i]] = struct{}{}
	}
}

// RemovedTblViewers returns the removed IDs of the "tbl_viewers" edge to the Viewers entity.
func (m *VideosMutation) RemovedTblViewersIDs() (ids []uint) {
	for id := range m.removedtbl_viewers {
		ids = append(ids, id)
	}
	return
}

// TblViewersIDs returns the "tbl_viewers" edge IDs in the mutation.
func (m *VideosMutation) TblViewersIDs() (ids []uint) {
	for id := range m.tbl_viewers {
		ids = append(ids, id)
	}
	return
}

// ResetTblViewers resets all changes to the "tbl_viewers" edge.
func (m *VideosMutation) ResetTblViewers() {
	m.tbl_viewers = nil
	m.clearedtbl_viewers = false
	m.removedtbl_viewers = nil
}

// AddTblObjectIDs adds the "tbl_objects" edge to the Objects entity by ids.
func (m *VideosMutation) AddTblObjectIDs(ids ...uint) {
	if m.tbl_objects == nil {
		m.tbl_objects = make(map[uint]struct{})
	}
	for i := range ids {
		m.tbl_objects[ids[i]] = struct{}{}
	}
}

// ClearTblObjects clears the "tbl_objects" edge to the Objects entity.
func (m *VideosMutation) ClearTblObjects() {
	m.clearedtbl_objects = true
}

// TblObjectsCleared reports if the "tbl_objects" edge to the Objects entity was cleared.
func (m *VideosMutation) TblObjectsCleared() bool {
	return m.clearedtbl_objects
}

// RemoveTblObjectIDs removes the "tbl_objects" edge to the Objects entity by IDs.
func (m *VideosMutation) RemoveTblObjectIDs(ids ...uint) {
	if m.removedtbl_objects == nil {
		m.removedtbl_objects = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.tbl_objects, ids[i])
		m.removedtbl_objects[ids[i]] = struct{}{}
	}
}

// RemovedTblObjects returns the removed IDs of the "tbl_objects" edge to the Objects entity.
func (m *VideosMutation) RemovedTblObjectsIDs() (ids []uint) {
	for id := range m.removedtbl_objects {
		ids = append(ids, id)
	}
	return
}

// TblObjectsIDs returns the "tbl_objects" edge IDs in the mutation.
func (m *VideosMutation) TblObjectsIDs() (ids []uint) {
	for id := range m.tbl_objects {
		ids = append(ids, id)
	}
	return
}

// ResetTblObjects resets all changes to the "tbl_objects" edge.
func (m *VideosMutation) ResetTblObjects() {
	m.tbl_objects = nil
	m.clearedtbl_objects = false
	m.removedtbl_objects = nil
}

// Where appends a list predicates to the VideosMutation builder.
func (m *VideosMutation) Where(ps ...predicate.Videos) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideosMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideosMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Videos, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideosMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideosMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Videos).
func (m *VideosMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideosMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, videos.FieldName)
	}
	if m.description != nil {
		fields = append(fields, videos.FieldDescription)
	}
	if m.video_url != nil {
		fields = append(fields, videos.FieldVideoURL)
	}
	if m._config != nil {
		fields = append(fields, videos.FieldConfig)
	}
	if m.path_resource != nil {
		fields = append(fields, videos.FieldPathResource)
	}
	if m.level_system != nil {
		fields = append(fields, videos.FieldLevelSystem)
	}
	if m.status != nil {
		fields = append(fields, videos.FieldStatus)
	}
	if m.note != nil {
		fields = append(fields, videos.FieldNote)
	}
	if m.assign != nil {
		fields = append(fields, videos.FieldAssign)
	}
	if m.version != nil {
		fields = append(fields, videos.FieldVersion)
	}
	if m._Author != nil {
		fields = append(fields, videos.FieldAuthor)
	}
	if m.created_at != nil {
		fields = append(fields, videos.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, videos.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, videos.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideosMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case videos.FieldName:
		return m.Name()
	case videos.FieldDescription:
		return m.Description()
	case videos.FieldVideoURL:
		return m.VideoURL()
	case videos.FieldConfig:
		return m.Config()
	case videos.FieldPathResource:
		return m.PathResource()
	case videos.FieldLevelSystem:
		return m.LevelSystem()
	case videos.FieldStatus:
		return m.Status()
	case videos.FieldNote:
		return m.Note()
	case videos.FieldAssign:
		return m.Assign()
	case videos.FieldVersion:
		return m.Version()
	case videos.FieldAuthor:
		return m.Author()
	case videos.FieldCreatedAt:
		return m.CreatedAt()
	case videos.FieldUpdatedAt:
		return m.UpdatedAt()
	case videos.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideosMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case videos.FieldName:
		return m.OldName(ctx)
	case videos.FieldDescription:
		return m.OldDescription(ctx)
	case videos.FieldVideoURL:
		return m.OldVideoURL(ctx)
	case videos.FieldConfig:
		return m.OldConfig(ctx)
	case videos.FieldPathResource:
		return m.OldPathResource(ctx)
	case videos.FieldLevelSystem:
		return m.OldLevelSystem(ctx)
	case videos.FieldStatus:
		return m.OldStatus(ctx)
	case videos.FieldNote:
		return m.OldNote(ctx)
	case videos.FieldAssign:
		return m.OldAssign(ctx)
	case videos.FieldVersion:
		return m.OldVersion(ctx)
	case videos.FieldAuthor:
		return m.OldAuthor(ctx)
	case videos.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case videos.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case videos.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Videos field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideosMutation) SetField(name string, value ent.Value) error {
	switch name {
	case videos.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case videos.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case videos.FieldVideoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoURL(v)
		return nil
	case videos.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case videos.FieldPathResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPathResource(v)
		return nil
	case videos.FieldLevelSystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelSystem(v)
		return nil
	case videos.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case videos.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case videos.FieldAssign:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssign(v)
		return nil
	case videos.FieldVersion:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case videos.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case videos.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case videos.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case videos.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Videos field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideosMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, videos.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideosMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case videos.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideosMutation) AddField(name string, value ent.Value) error {
	switch name {
	case videos.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Videos numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideosMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(videos.FieldDescription) {
		fields = append(fields, videos.FieldDescription)
	}
	if m.FieldCleared(videos.FieldDeletedAt) {
		fields = append(fields, videos.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideosMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideosMutation) ClearField(name string) error {
	switch name {
	case videos.FieldDescription:
		m.ClearDescription()
		return nil
	case videos.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Videos nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideosMutation) ResetField(name string) error {
	switch name {
	case videos.FieldName:
		m.ResetName()
		return nil
	case videos.FieldDescription:
		m.ResetDescription()
		return nil
	case videos.FieldVideoURL:
		m.ResetVideoURL()
		return nil
	case videos.FieldConfig:
		m.ResetConfig()
		return nil
	case videos.FieldPathResource:
		m.ResetPathResource()
		return nil
	case videos.FieldLevelSystem:
		m.ResetLevelSystem()
		return nil
	case videos.FieldStatus:
		m.ResetStatus()
		return nil
	case videos.FieldNote:
		m.ResetNote()
		return nil
	case videos.FieldAssign:
		m.ResetAssign()
		return nil
	case videos.FieldVersion:
		m.ResetVersion()
		return nil
	case videos.FieldAuthor:
		m.ResetAuthor()
		return nil
	case videos.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case videos.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case videos.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Videos field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideosMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tbl_comments != nil {
		edges = append(edges, videos.EdgeTblComments)
	}
	if m.tbl_reactions != nil {
		edges = append(edges, videos.EdgeTblReactions)
	}
	if m.tbl_viewers != nil {
		edges = append(edges, videos.EdgeTblViewers)
	}
	if m.tbl_objects != nil {
		edges = append(edges, videos.EdgeTblObjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideosMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case videos.EdgeTblComments:
		ids := make([]ent.Value, 0, len(m.tbl_comments))
		for id := range m.tbl_comments {
			ids = append(ids, id)
		}
		return ids
	case videos.EdgeTblReactions:
		ids := make([]ent.Value, 0, len(m.tbl_reactions))
		for id := range m.tbl_reactions {
			ids = append(ids, id)
		}
		return ids
	case videos.EdgeTblViewers:
		ids := make([]ent.Value, 0, len(m.tbl_viewers))
		for id := range m.tbl_viewers {
			ids = append(ids, id)
		}
		return ids
	case videos.EdgeTblObjects:
		ids := make([]ent.Value, 0, len(m.tbl_objects))
		for id := range m.tbl_objects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideosMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtbl_comments != nil {
		edges = append(edges, videos.EdgeTblComments)
	}
	if m.removedtbl_reactions != nil {
		edges = append(edges, videos.EdgeTblReactions)
	}
	if m.removedtbl_viewers != nil {
		edges = append(edges, videos.EdgeTblViewers)
	}
	if m.removedtbl_objects != nil {
		edges = append(edges, videos.EdgeTblObjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideosMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case videos.EdgeTblComments:
		ids := make([]ent.Value, 0, len(m.removedtbl_comments))
		for id := range m.removedtbl_comments {
			ids = append(ids, id)
		}
		return ids
	case videos.EdgeTblReactions:
		ids := make([]ent.Value, 0, len(m.removedtbl_reactions))
		for id := range m.removedtbl_reactions {
			ids = append(ids, id)
		}
		return ids
	case videos.EdgeTblViewers:
		ids := make([]ent.Value, 0, len(m.removedtbl_viewers))
		for id := range m.removedtbl_viewers {
			ids = append(ids, id)
		}
		return ids
	case videos.EdgeTblObjects:
		ids := make([]ent.Value, 0, len(m.removedtbl_objects))
		for id := range m.removedtbl_objects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideosMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtbl_comments {
		edges = append(edges, videos.EdgeTblComments)
	}
	if m.clearedtbl_reactions {
		edges = append(edges, videos.EdgeTblReactions)
	}
	if m.clearedtbl_viewers {
		edges = append(edges, videos.EdgeTblViewers)
	}
	if m.clearedtbl_objects {
		edges = append(edges, videos.EdgeTblObjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideosMutation) EdgeCleared(name string) bool {
	switch name {
	case videos.EdgeTblComments:
		return m.clearedtbl_comments
	case videos.EdgeTblReactions:
		return m.clearedtbl_reactions
	case videos.EdgeTblViewers:
		return m.clearedtbl_viewers
	case videos.EdgeTblObjects:
		return m.clearedtbl_objects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideosMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Videos unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideosMutation) ResetEdge(name string) error {
	switch name {
	case videos.EdgeTblComments:
		m.ResetTblComments()
		return nil
	case videos.EdgeTblReactions:
		m.ResetTblReactions()
		return nil
	case videos.EdgeTblViewers:
		m.ResetTblViewers()
		return nil
	case videos.EdgeTblObjects:
		m.ResetTblObjects()
		return nil
	}
	return fmt.Errorf("unknown Videos edge %s", name)
}

// ViewersMutation represents an operation that mutates the Viewers nodes in the graph.
type ViewersMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	number            *int
	addnumber         *int
	time_point        *float64
	addtime_point     *float64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	tbl_videos        *uint
	clearedtbl_videos bool
	done              bool
	oldValue          func(context.Context) (*Viewers, error)
	predicates        []predicate.Viewers
}

var _ ent.Mutation = (*ViewersMutation)(nil)

// viewersOption allows management of the mutation configuration using functional options.
type viewersOption func(*ViewersMutation)

// newViewersMutation creates new mutation for the Viewers entity.
func newViewersMutation(c config, op Op, opts ...viewersOption) *ViewersMutation {
	m := &ViewersMutation{
		config:        c,
		op:            op,
		typ:           TypeViewers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withViewersID sets the ID field of the mutation.
func withViewersID(id uint) viewersOption {
	return func(m *ViewersMutation) {
		var (
			err   error
			once  sync.Once
			value *Viewers
		)
		m.oldValue = func(ctx context.Context) (*Viewers, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Viewers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withViewers sets the old Viewers of the mutation.
func withViewers(node *Viewers) viewersOption {
	return func(m *ViewersMutation) {
		m.oldValue = func(context.Context) (*Viewers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ViewersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ViewersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Viewers entities.
func (m *ViewersMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ViewersMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ViewersMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Viewers.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVideoID sets the "video_id" field.
func (m *ViewersMutation) SetVideoID(u uint) {
	m.tbl_videos = &u
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *ViewersMutation) VideoID() (r uint, exists bool) {
	v := m.tbl_videos
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the Viewers entity.
// If the Viewers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ViewersMutation) OldVideoID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *ViewersMutation) ResetVideoID() {
	m.tbl_videos = nil
}

// SetNumber sets the "number" field.
func (m *ViewersMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *ViewersMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Viewers entity.
// If the Viewers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ViewersMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *ViewersMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *ViewersMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *ViewersMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetTimePoint sets the "time_point" field.
func (m *ViewersMutation) SetTimePoint(f float64) {
	m.time_point = &f
	m.addtime_point = nil
}

// TimePoint returns the value of the "time_point" field in the mutation.
func (m *ViewersMutation) TimePoint() (r float64, exists bool) {
	v := m.time_point
	if v == nil {
		return
	}
	return *v, true
}

// OldTimePoint returns the old "time_point" field's value of the Viewers entity.
// If the Viewers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ViewersMutation) OldTimePoint(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimePoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimePoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimePoint: %w", err)
	}
	return oldValue.TimePoint, nil
}

// AddTimePoint adds f to the "time_point" field.
func (m *ViewersMutation) AddTimePoint(f float64) {
	if m.addtime_point != nil {
		*m.addtime_point += f
	} else {
		m.addtime_point = &f
	}
}

// AddedTimePoint returns the value that was added to the "time_point" field in this mutation.
func (m *ViewersMutation) AddedTimePoint() (r float64, exists bool) {
	v := m.addtime_point
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimePoint resets all changes to the "time_point" field.
func (m *ViewersMutation) ResetTimePoint() {
	m.time_point = nil
	m.addtime_point = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ViewersMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ViewersMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Viewers entity.
// If the Viewers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ViewersMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ViewersMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ViewersMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ViewersMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Viewers entity.
// If the Viewers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ViewersMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ViewersMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ViewersMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ViewersMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Viewers entity.
// If the Viewers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ViewersMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ViewersMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[viewers.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ViewersMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[viewers.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ViewersMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, viewers.FieldDeletedAt)
}

// SetTblVideosID sets the "tbl_videos" edge to the Videos entity by id.
func (m *ViewersMutation) SetTblVideosID(id uint) {
	m.tbl_videos = &id
}

// ClearTblVideos clears the "tbl_videos" edge to the Videos entity.
func (m *ViewersMutation) ClearTblVideos() {
	m.clearedtbl_videos = true
	m.clearedFields[viewers.FieldVideoID] = struct{}{}
}

// TblVideosCleared reports if the "tbl_videos" edge to the Videos entity was cleared.
func (m *ViewersMutation) TblVideosCleared() bool {
	return m.clearedtbl_videos
}

// TblVideosID returns the "tbl_videos" edge ID in the mutation.
func (m *ViewersMutation) TblVideosID() (id uint, exists bool) {
	if m.tbl_videos != nil {
		return *m.tbl_videos, true
	}
	return
}

// TblVideosIDs returns the "tbl_videos" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TblVideosID instead. It exists only for internal usage by the builders.
func (m *ViewersMutation) TblVideosIDs() (ids []uint) {
	if id := m.tbl_videos; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTblVideos resets all changes to the "tbl_videos" edge.
func (m *ViewersMutation) ResetTblVideos() {
	m.tbl_videos = nil
	m.clearedtbl_videos = false
}

// Where appends a list predicates to the ViewersMutation builder.
func (m *ViewersMutation) Where(ps ...predicate.Viewers) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ViewersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ViewersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Viewers, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ViewersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ViewersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Viewers).
func (m *ViewersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ViewersMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tbl_videos != nil {
		fields = append(fields, viewers.FieldVideoID)
	}
	if m.number != nil {
		fields = append(fields, viewers.FieldNumber)
	}
	if m.time_point != nil {
		fields = append(fields, viewers.FieldTimePoint)
	}
	if m.created_at != nil {
		fields = append(fields, viewers.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, viewers.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, viewers.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ViewersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case viewers.FieldVideoID:
		return m.VideoID()
	case viewers.FieldNumber:
		return m.Number()
	case viewers.FieldTimePoint:
		return m.TimePoint()
	case viewers.FieldCreatedAt:
		return m.CreatedAt()
	case viewers.FieldUpdatedAt:
		return m.UpdatedAt()
	case viewers.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ViewersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case viewers.FieldVideoID:
		return m.OldVideoID(ctx)
	case viewers.FieldNumber:
		return m.OldNumber(ctx)
	case viewers.FieldTimePoint:
		return m.OldTimePoint(ctx)
	case viewers.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case viewers.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case viewers.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Viewers field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ViewersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case viewers.FieldVideoID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case viewers.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case viewers.FieldTimePoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimePoint(v)
		return nil
	case viewers.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case viewers.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case viewers.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Viewers field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ViewersMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, viewers.FieldNumber)
	}
	if m.addtime_point != nil {
		fields = append(fields, viewers.FieldTimePoint)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ViewersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case viewers.FieldNumber:
		return m.AddedNumber()
	case viewers.FieldTimePoint:
		return m.AddedTimePoint()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ViewersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case viewers.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case viewers.FieldTimePoint:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimePoint(v)
		return nil
	}
	return fmt.Errorf("unknown Viewers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ViewersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(viewers.FieldDeletedAt) {
		fields = append(fields, viewers.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ViewersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ViewersMutation) ClearField(name string) error {
	switch name {
	case viewers.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Viewers nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ViewersMutation) ResetField(name string) error {
	switch name {
	case viewers.FieldVideoID:
		m.ResetVideoID()
		return nil
	case viewers.FieldNumber:
		m.ResetNumber()
		return nil
	case viewers.FieldTimePoint:
		m.ResetTimePoint()
		return nil
	case viewers.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case viewers.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case viewers.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Viewers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ViewersMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tbl_videos != nil {
		edges = append(edges, viewers.EdgeTblVideos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ViewersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case viewers.EdgeTblVideos:
		if id := m.tbl_videos; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ViewersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ViewersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ViewersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtbl_videos {
		edges = append(edges, viewers.EdgeTblVideos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ViewersMutation) EdgeCleared(name string) bool {
	switch name {
	case viewers.EdgeTblVideos:
		return m.clearedtbl_videos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ViewersMutation) ClearEdge(name string) error {
	switch name {
	case viewers.EdgeTblVideos:
		m.ClearTblVideos()
		return nil
	}
	return fmt.Errorf("unknown Viewers unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ViewersMutation) ResetEdge(name string) error {
	switch name {
	case viewers.EdgeTblVideos:
		m.ResetTblVideos()
		return nil
	}
	return fmt.Errorf("unknown Viewers edge %s", name)
}
